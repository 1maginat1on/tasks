# -*- coding: utf-8 -*-
"""task

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g45IbRoRMmGoj-3QgrzzSNIMeqOk7Au1
"""

# Ниже приведена функция, работающая со списками, в ней есть баг. Исходя из описания функции,
# найдите в ней баг

def has_lucky_number(nums):
    """Возвращает, является ли данный список чисел счастливым. Счастливый список должен
    содержать по крайней мере одно число, кратное 7
    """
    for num in nums:
        if num % 7 == 0:
            return True
        else:
            return False

# Реализуйте функцию is_year_leap, которая принимает на вход год,
# и возвращает информацию о том, является ли год високосным

# https://ru.wikihow.com/%D0%B2%D1%8B%D1%81%D1%87%D0%B8%D1%82%D1%8B%D0%B2%D0%B0%D1%82%D1%8C-%D0%B2%D0%B8%D1%81%D0%BE%D0%BA%D0%BE%D1%81%D0%BD%D1%8B%D0%B5-%D0%B3%D0%BE%D0%B4%D1%8B

year = int(input())
if (year % 4 == 0) and (year % 100 != 0) or (year % 400 == 0):
    print('YES')
else:
    print('NO')

# Написать функцию square, принимающую 1 аргумент — сторону квадрата,
# и возвращающую 3 значения (в виде кортежа): периметр квадрата,
# площадь квадрата и диагональ квадрата
from math import *
a=int(input())
print(4*a, a*a, a*sqrt(2))

#Пользователь делает вклад в размере a рублей сроком на years лет под m% годовых (каждый год размер его вклада
# увеличивается на m%. Эти деньги прибавляются к сумме вклада, и на них в следующем году тоже будут проценты).
#Написать функцию count_money, принимающая аргументы initial_money_amount,
# percent и years, и возвращающую сумму, которая будет на счету пользователя к концу переиода
from math import *
a=int(input())
years=int(input())
m=int(input())
for i in range(years):
    a=a+a*m/100
print(a)
# Предлагается реализовать функцию, сравнивающую каждый элемент списка с заданным числом.
s=input().split()
n=int(input())
for i in range(len(s)):
    s[i] = int(s[i])
    if s[i]==n:
        print(s[i], "=", n)
    else:
        print(s[i], '!=', n)



def is_valid_zip(zip_code):
    """Проверяет индес на валидность. Будем считать, что почтовый индекс валиден, если он состоит из 6 цифр"""
    pass

assert(is_valid_zip('123456') == True)
assert(is_valid_zip('12345a') == False)

# Исследователь собрал тысячи новостных статей. Ему требуется отобрать из этих статей лишь те,
# которые содержат определенное слово. Закончите функцию ниже.

# - Документы содержащие искомое слово внутри другого не должны учитываться (например слово
# "москит", если мы ищем документы со словом "кит")
# - Слова написанные буквами в разном регистре это одни и те же слова (например "кот" то же, что и
# "Кот")
# - Если за словом идет знак препинания, это не должно влиять на поиск (например, если в тексте
# есть "башмак, который порван", то по слову "башмак" мы должны выдавать этот текст)

def word_search(doc_list, keyword):
    """
    Принимает список документов doc_list (каждый документ представляет собой строку) и ключевое слово.
    Возвращает список значений индекса в исходный список для всех документов, содержащих ключевое слово. """
    pass

doc_list = ["Москит укусил туриста", "Кит, в Тихом океане", "Кот-бегемот"]
print(word_search(doc_list, 'кит'))

# EXTRA TASK 1
# Рассчитать ежемесячные выплаты (m) и суммарную выплату (s) по кредиту.
# О кредите известно, что он составляет n рублей, берется на y лет, под p процентов
# Месячные выплаты находятся по формуле:
# m = (n * p * (1 + p)y) / (12 * ((1 + p)y – 1)), где p выражается в долях единицы, а не процентах.

#Суммарная выплата представляет собой выплаты за все месяцы каждого года:
# s = (m * 12) * y

# EXTRA TASK 2
# Написать функцию XOR_cipher, принимающая 2 аргумента: строку, которую нужно зашифровать,
# и ключ шифрования, которая возвращает строку, зашифрованную путем применения функции XOR (^)
# над символами строки с ключом. Написать также функцию XOR_uncipher, которая по зашифрованной
# строке и ключу восстанавливает исходную строку.

# EXTRA TASK 3
# Написать функцию date, принимающую 3 аргумента — день, месяц и год. Вернуть True,
# если такая дата есть в нашем календаре, и False иначе (воспользуйтесь функцией is_leap_year)